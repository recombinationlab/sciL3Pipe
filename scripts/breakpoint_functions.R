

#' loads an RData file, and returns it
#' @param f RData file path
#' 
load_RData <- function(f){
  env <- new.env()
  nm <- load(f, env)[1]
  env[[nm]]
}

#' Load breakpoint RData
#' 
#' @param folder Data folder generated by breakpointR
#' @param prefix variable name prefix
#' 
load_breakpoint <- function(folder, prefix=NULL, keep_postfix=FALSE, envir=.GlobalEnv){
  rdata_files <- list.files(folder, pattern = "*.RData$", 
                            full.names = TRUE)
  
  for(f in rdata_files){
    if(keep_postfix){
      if(is.null(prefix)){
        f_name <- basename(f)
      }else{
        f_name <- paste(prefix, basename(f), sep = "")
      }
    }else{
      if(is.null(prefix)){
        f_name <- unlist(strsplit(basename(f), ".bam.RData"))
      }else{
        f_name <- paste(prefix, unlist(strsplit(basename(f), ".bam.RData")), sep = "")
      }
    }
    assign(f_name, load_RData(f), envir = envir)
  }
}


#' Extract metrics from BreakPoint object into a summary table
#' background.estimate
#' med.reads.per.MB
#' perc.coverage
#' Number of breaks detected
#' 
#' @param pattern pattern of variables in the GlobalEnv to be used
#' 
breakpoint_summary <- function(pattern){
  all_metrics <- list()
  for(v in ls(pattern = pattern, envir = .GlobalEnv)){
    if("original_breaks" %in% names(get(v))){
      all_metrics[[v]] <- data.frame(as.list(get(v)$lib.metrics),
                                     original_breaks=length(get(v)$original_breaks),
                                     breaks=length(get(v)$breaks))
    }else{
      all_metrics[[v]] <- data.frame(as.list(get(v)$lib.metrics),
                                     breaks=length(get(v)$breaks))
    }
    
  }
  out <- plyr::ldply(all_metrics, rbind)
  return(out)
}




#' Filter two breakpoint event close to each other
#' 
#' @param object BreakPoint class object
#' @param distance_cutoff min distance allowed between two neighbouring breakpoints
double_event_filter <- function(object, distance_cutoff=1000000, pdf_dir=FALSE){
  
  # if pdf_dir does not exist, create it
  if (!file.exists(pdf_dir)){
    dir.create(file.path(pdf_dir))
  }
  
  if(is.character(pdf_dir)){
    cat("Saving PDF:", paste(pdf_dir, object$ID, ".pdf", sep = ""), "\n")
    grDevices::pdf(paste(pdf_dir, object$ID, ".pdf", sep = ""), 
                   width = max(10, length(seqinfo(object$breaks))), 
                   height = 5)
    print(breakpointR::plotBreakpoints(object))
  }
  
  if(length(object$breaks) > 0){
    dtn <- distanceToNearest(object$breaks)
    mcols(object$breaks)$distance <- NA
    object$breaks[queryHits(dtn)]$distance <- mcols(dtn)$distance
    object$original_breaks <- object$breaks
    object$breaks <- object$breaks[object$breaks$distance > distance_cutoff | is.na(object$breaks$distance)]
    
    if(is.character(pdf_dir)){
      print(breakpointR::plotBreakpoints(object))
      grDevices::dev.off()
    }
  }else{
    grDevices::dev.off()
  }
  return(object)
}


#' Filter two breakpoint event close to each other, a version without plotting
#' that only adds a TRUE/FALSE mcolumn to the original breaks GRanges
#' 
#' @param object BreakPoint class object
#' @param distance_cutoff min distance allowed between two neighbouring breakpoints
#' 
de_filter <- function(object, distance_cutoff=1000000){
  
  if(length(object$breaks) > 0){
    dtn <- distanceToNearest(object$breaks)
    mcols(object$breaks)$distance <- NA
    object$breaks[queryHits(dtn)]$distance <- mcols(dtn)$distance
    mcols(object$breaks)$de_keep <- object$breaks$distance > distance_cutoff | is.na(object$breaks$distance)
  }
  return(object)
}

#' breaks that are nearest to each other (inversion breaks), test if they have 
#' the same genotype on either side of the inversion. If yes, filter. If not, 
#' this should be a breakpoint, and should be merged into a single (low resolution)
#' breakpoint
#' 
#' Note: destructive, overwrite the original breaks GRanges in object, should be run last
#' 
#' @param object breakpointR class object
#' @param distance_cutoff distance of proximal breakpoints to assess
#' @param allow_het allow wc or cw genotypes (for diploid)
#' 
genoT_nearest_filter <- function(object, distance_cutoff=2000000, allow_het=FALSE){
  
  # add distance to nearest if not present
  if(!"distance" %in% names(mcols(object$breaks))){
    dtn <- distanceToNearest(object$breaks)
    mcols(object$breaks)$distance <- NA
    object$breaks[queryHits(dtn)]$distance <- mcols(dtn)$distance
  }
  
  # NA to -1 for split to keep all rows
  object$breaks$distance[is.na(object$breaks$distance)] <- -1
  # Add new mcols to keep track if pairs were merged
  mcols(object$breaks)$merged <- FALSE
  pairs <- split(object$breaks, object$breaks$distance)
  
  final_breaks <- list()
  for(p in seq_along(pairs)){
    n <- as.character(p)
    # if not a proper pair skip filter
    if(length(pairs[[p]]) != 2 | any(pairs[[p]]$distance == -1)){
      final_breaks[[n]] <- pairs[[p]]
    }else if(all(pairs[[p]]$distance <= distance_cutoff)){
      # check order
      stopifnot(start(pairs[[p]][1]) < start(pairs[[p]][2]))
      
      p1g <- substr(pairs[[p]][1]$genoT, 1, 2) 
      p2g <- substr(pairs[[p]][2]$genoT, 4, 5)
      
      # if sides of breaks same, remove both breaks
      if(p1g == p2g){
        next
      }else if(allow_het){
        # create new ranges with pairs merged
        final_breaks[[n]] <- merge_bR_pairs(pairs[[p]])
      }else if(p1g %in% c("ww", "cc") & p2g %in% c("ww", "cc") & p1g != p2g){
        final_breaks[[n]] <- merge_bR_pairs(pairs[[p]])
      }
    # anything more than distance cutoff write out
    }else{
      final_breaks[[n]] <- pairs[[p]]
    }
  }
 object$breaks <- unlist(GRangesList(final_breaks))
 
 return(object)
}
  
#' If a breakpoint falls within a centromere, find the nearest breakpoint and 
#' test the genotype. If WW-WW or CC-CC on both sides, remove both breaks.
#' 
#' @param object BreakpointR class object
#' @param cent centromere coordinates GRanges
#' @param assembly hg19 hg38 or mm10 to retrieve centromere coordinates from biomart
#' @param distance_cutoff distance from centromere to consider breakpoints as nearest
#' 
genoT_cent_filter <- function(object, cent, assembly, distance_cutoff=3000000){

  # add distance to nearest if not present
  if(!"distance" %in% names(mcols(object$breaks))){
    dtn <- distanceToNearest(object$breaks)
    mcols(object$breaks)$distance <- NA
    object$breaks[queryHits(dtn)]$distance <- mcols(dtn)$distance
  }
  
  hits <- findOverlaps(cent, object$breaks)
  
  # NA to -1 for split to keep all rows
  object$breaks$distance[is.na(object$breaks$distance)] <- -1
  # Add new mcols to keep track if one of a pair overlaps with centromere
  mcols(object$breaks)$centromere <- FALSE
  mcols(object$breaks)$centromere_keep <- TRUE
  mcols(object$breaks)$centromere[subjectHits(hits)] <- TRUE
  
  pairs <- split(object$breaks, object$breaks$distance)
  
  final_breaks <- list()
  for(p in seq_along(pairs)){
    n <- as.character(p)
    # if any contain centromere overlapping
    if(any(pairs[[p]]$centromere)){
      
      if(length(pairs[[p]]) != 2 | any(pairs[[p]]$distance == -1)){
        final_breaks[[n]] <- pairs[[p]]
      }else if(all(pairs[[p]]$distance <= distance_cutoff)){
        # check order
        stopifnot(start(pairs[[p]][1]) < start(pairs[[p]][2]))
        
        p1g <- substr(pairs[[p]][1]$genoT, 1, 2) 
        p2g <- substr(pairs[[p]][2]$genoT, 4, 5)
        
        # if sides of breaks same, remove both breaks
        if(p1g == p2g){
          pairs[[p]]$centromere_keep <- FALSE
          final_breaks[[n]] <- pairs[[p]]
        }else{
          final_breaks[[n]] <- pairs[[p]]
        }
      }
    # anything more than distance cutoff write out
    }else{
      final_breaks[[n]] <- pairs[[p]]
      }
  }
  object$breaks <- unlist(GRangesList(final_breaks))
  return(object)  
}

# test <- genoT_cent_filter(yi293_GAACCG.CATTGTGTCGGAGAC.human.bam.RData, "hg19")

  
#'Merge a Pair of GRanges
#'
#'Note: requires distance column
#'
#'@param pairs GRanges with two ranges with equal distance from each other
#'
merge_bR_pairs <- function(pair){
  stopifnot("distance" %in% names(mcols(pair)))
  
  dist <- ifelse(pair[1]$distance == pair[2]$distance, pair[1]$distance, stop("Distance unequal"))
  
  p1g <- substr(pair[1]$genoT, 1, 2) 
  p2g <- substr(pair[2]$genoT, 4, 5)
  
  # merge pair coordinates
  m_pair <- reduce(pair, min.gapwidth= dist+1)
  mcols(m_pair) <- mcols(pair[1])
  mcols(m_pair)$genoT <- paste(p1g, p2g, sep = "-")
  mcols(m_pair)$deltaW <- mean(pair[1]$deltaW, pair[2]$deltaW)
  mcols(m_pair)$distance <- -1
  mcols(m_pair)$de_keep <- TRUE
  mcols(m_pair)$merged <- TRUE
  
  return(m_pair)
}
  
  # seqnames     start       end    width strand genoT deltaW distance de_keep
  # 1         1 120447865 145462905 25015041      * ww-cc     12  1881056   FALSE
  # 2         1 147343962 149121706  1777745      * cc-ww     11  1881056   FALSE
  # 3         8  24372672  24816691   444020      * ww-wc      6   483415   FALSE
  # 4         8  25300107  25719608   419502      * wc-ww      6   483415   FALSE
  # 5         9 133300206 133971276   671071      * ww-cc     14       NA    TRUE
  # 6        10  46032485  46967406   934922      * cc-wc      8  1645976   FALSE
  # 7        10  48613383  49507614   894232      * wc-cc      6  1645976   FALSE
  # 8        12  63132183  63270986   138804      * ww-cc      9   749859   FALSE
  # 9        12  64020846  64410553   389708      * cc-ww      9   749859   FALSE
  # 10       15  23701352  23977707   276356      * ww-cc     13 36611739    TRUE
  # 11       15  60589447  61121067   531621      * cc-wc     12 11481023    TRUE
  # 12       15  72602091  72604997     2907      * wc-cc     11  1709137   FALSE
  # 13       15  74314135  74511749   197615      * cc-wc     11  1709137   FALSE
  # 14       15  89828254  89849202    20949      * wc-cc      9 15316504    TRUE
  # 15       22  23716264  23756067    39804      * cc-ww      9       NA    TRUE

# If using confidence intervals, some ranges will be falsely merged as the example chr16 below:
# seqnames              ranges strand |  BP.start    BP.end       genoT    deltaW  distance   de_keep region_filter  hom_keep
# <Rle>           <IRanges>  <Rle> | <integer> <integer> <character> <numeric> <numeric> <logical>     <logical> <logical>
# [1]        9 129861224-140206736      * | 133300206 133971276       ww-cc        11        -1      TRUE          TRUE      TRUE
# [2]       22   22797039-31179221      * |  23576388  23756067       cc-ww         9        -1      TRUE          TRUE      TRUE
# [3]       16   29783361-33609279      * |  31892223  32476932       cc-ww         9   2569287      TRUE          TRUE      TRUE
# [4]       16   33609192-52248529      * |  35046220  46556596       ww-cc         9   2569287      TRUE          TRUE      TRUE
# Use merged column to merge intervals, so only breaks that have been merged will be reduced to get proper interval 



#' Heterozygous breakpoint filter, useful for haploid cell lines
#' 
#' #' @param object BreakPoint class object
#' 
hom_filter <- function(object){
  if(length(object$breaks) > 0){
    mcols(object$breaks)$hom_keep <- mcols(object$breaks)$genoT == "cc-ww" | mcols(object$breaks)$genoT == "ww-cc"
  }
  return(object)
}




#' Get centromere coordinates from UCSC 
#' 
#' Note: in hg19 centromeres are treated as gaps
#' trackNames(ucscTableQuery(session))
#' 
#' @param genome e.g. hg38
#' @param reduce_single reduce to a single coordinate per chromosome (for hg38 that contains centromeres)
#' @param ensembl convert coordinates to ensembl format (i.e. chr1 -> 1)
#' 
get_centromere_coordinates <- function(genome, reduce_single=FALSE, ensembl=FALSE){
  if (!(exists("session") && extends(class(session), "BrowserSession"))) 
    session <- rtracklayer::browserSession()
  if(genome == "hg38"){
    tryres <- try(query <- rtracklayer::ucscTableQuery(session, "centromeres", genome))
  }else {
    tryres <- try(query <- rtracklayer::ucscTableQuery(session, "gap", genome))
  }
  
  
  if (!inherits(tryres, "try-error")) {
    df <- rtracklayer::getTable(query)
    if(genome != "hg38"){
      df <- df[df$type == "centromere",]
    }
    gr <- GRanges(seqnames = df$chrom, IRanges(start = df$chromStart, 
                                               end = df$chromEnd))
  } else {
    message("Centromere informatin is not available.")
  }
  
  if(reduce_single){
    max_dist <- max(mcols(distanceToNearest(gr))$distance)
    gr <- reduce(gr, min.gapwidth= max_dist+1)
  }
  
  if(ensembl){
    gr <- diffloop::rmchr(gr)
  }
  
  return(gr)
}



#' Load file with all breakpoints including columns:
#' seqnames start end CI.start CI.end genoT filenames
#' 
#' Makes a list with breakpoints for each sample in summary file
#' 
#' @param file_path path to breakPointsSummary*.txt file
#' @param switch_coordinates switch GRanges coordinates to the confidence interval coordiantes (CI)
#' 
load_breakpoint_summary <- function(file_path, switch_coordinates=FALSE){
  # space delimited, can't import as a BED file
  bp_summary <- readr::read_table2(file_path)
  # remove breakpoint number from filenames
  bp_summary$filenames <- gsub(".\\d+$", "", bp_summary$filenames)
  if(switch_coordinates){
    bp_summary <- dplyr::rename(bp_summary, BP.start = start, BP.end = end)
    bp_summary <- makeGRangesFromDataFrame(bp_summary, keep.extra.columns=TRUE,
                                           start.field = "CI.start",
                                           end.field = "CI.end")
  }else{
    bp_summary <- makeGRangesFromDataFrame(bp_summary, keep.extra.columns=TRUE)
  }
  
  summary_list <- split(bp_summary, bp_summary$filenames)
  
  return(summary_list)
}



#' Exclude chromosomes or certain regions as possible sites of breakpoints
#' 
#' @param object breakpoint class object
#' @param region either chromosome "15" or region "15:1-500" to exclude
#' 
#' @return breakpoint class object with region_filter column added to breaks GRanges
#' 
filter_regions <- function(object, region){
  if(grepl(":|-", region)){
    region <- gsub(":", "-", region)
    rs <- unlist(strsplit(region, "-"))
    region <- GRanges(seqnames = rs[1], 
                      ranges = IRanges(start=as.numeric(rs[2]), end=as.numeric(rs[3])))
    hits <- findOverlaps(object$breaks, region)
    # exclude overlaps
    mcols(object$breaks)$region_filter <- !object$breaks %in% object$breaks[queryHits(hits)]
  }else{
    mcols(object$breaks)$region_filter <- !seqnames(object$breaks) %in% region
  }
  return(object)
}



#' False positive/negative evaluation of breakpoints based on a list true calls
#' 
#' @param true_bp path or GRangesList of True breakpoints
#' @param eval_bp path or GRangesList of breakpoints to be evaluated
#' 
fpn_evaluation <- function(true_bp, eval_bp){
  if(is.character(true_bp)){
    tbp <- load_breakpoint_summary(true_bp)
  }else{
    # if not a character assumes to be a GRangesList
    tbp <- true_bp
  }
  if(is.character(eval_bp)){
    ebp <- load_breakpoint_summary(eval_bp)
  }else{
    ebp <- eval_bp
  }
  
  bp_eval <- list()
  for(f in names(ebp)){
    hits <- findOverlaps(tbp[[f]], ebp[[f]])
    # true
    tp <- length(subjectHits(hits))
    # false positive
    fp <- length(ebp[[f]]) - tp
    # false negative
    fn <- length(tbp[[f]]) - tp
    
    bp_eval[[f]]<- data.frame(true=tp, fp=fp, fn=fn)
  }
  
  bp_eval_df <- plyr::ldply(bp_eval, rbind)
  
  return(bp_eval_df)
  
}

#' Add confidence interval ranges to break points as mcol
#' 
#' @param object BreakpointR class object
#' 
confint_to_breaks <- function(object){
  
  # make sure breaks and confint have correct row positions 
  # should be by default, but better not to assume)
  breaks <- sortSeqlevels(object$breaks)
  breaks <- sort(breaks)
  
  confint <- sortSeqlevels(object$confint)
  confint <- sort(confint)
  
  mcols(breaks)$CI.start <- start(confint)
  mcols(breaks)$CI.end <- end(confint)
  
  object$breaks <- breaks
  
  return(object)
}



#' False positive/negative evaluation of breakpoints based on a list true calls
#' 
#' @param true_bp path or GRangesList of True breakpoints
#' @param data_folder path to breakpoints data to be evaluated
#' @param distance_cutoff for inversions/breaks close to each other, distance to ignore such events
#' @param filt exclude breakpoints by chromosome "15" or regions (GRanges)
#' 
fpn_filter_evaluation <- function(true_bp, data_folder, distance_cutoff=2000000, filt=NULL, assembly="hg19"){
  if(is.character(true_bp)){
    # Use CI coordinates for identifying true breakpoints
    tbp <- load_breakpoint_summary(true_bp, switch_coordinates = TRUE)
  }else{
    # if not a character assumes to be a GRangesList
    tbp <- true_bp
  }
  
  #load centromere coordinates
  cent <- get_centromere_coordinates(assembly, FALSE, ensembl = TRUE)
  
  # load breakpoint data only within function environment
  load_breakpoint(data_folder, prefix = "", keep_postfix=TRUE, envir = environment())
  
  bp_eval <- list()
  de <- list()
  deh <- list()
  deg <- list()
  degh <- list()
  deghc <- list()
  for(f in ls(pattern = "\\.RData$")){
    print(paste("Evaluating:", f, sep = " "))
    
    bpdata <- confint_to_breaks(get(f))
    
    hits <- findOverlaps(tbp[[f]], bpdata$confint)
    # total true
    all_t <- length(tbp[[f]])
    # true
    tp <- length(subjectHits(hits))
    # false positive
    fp <- length(bpdata$breaks) - tp
    # false negative
    fn <- all_t - tp
    
    # get breakpoint resolution of true positives
    med_res <- median(width(bpdata$breaks[subjectHits(hits)]))
    
    de_filt <- de_filter(bpdata, distance_cutoff)
    
    
    if(!is.null(filt)){
      de_filt <- filter_regions(de_filt, filt)  
      post_rf <- sum(de_filt$breaks$region_filter*1)
      
      post_de <- sum((de_filt$breaks$de_keep & de_filt$breaks$region_filter)*1)
      
      deh_filt <- hom_filter(de_filt)
      post_deh <- sum((deh_filt$breaks$de_keep & deh_filt$breaks$hom_keep & deh_filt$breaks$region_filter)*1)
      
      deg_filt <- genoT_nearest_filter(de_filt, distance_cutoff)
      post_deg <- sum((deg_filt$breaks$de_keep & deg_filt$breaks$region_filter)*1)
      
      degh_filt <- hom_filter(deg_filt)
      post_degh <- sum((degh_filt$breaks$de_keep & degh_filt$breaks$hom_keep & degh_filt$breaks$region_filter)*1)
      
      deghc_filt <- genoT_cent_filter(degh_filt, cent, assembly, 3000000)
      post_deghc <- sum((deghc_filt$breaks$de_keep & deghc_filt$breaks$hom_keep & deghc_filt$breaks$region_filter & deghc_filt$breaks$centromere_keep)*1)
      
      deghc_breaks <- tibble::as_tibble(deghc_filt$breaks[deghc_filt$breaks$de_keep & deghc_filt$breaks$region_filter & deghc_filt$breaks$hom_keep & deghc_filt$breaks$centromere_keep])
    }else{
      post_rf <- NA
      
      deh_filt <- hom_filter(de_filt)
      post_deh <- sum((deh_filt$breaks$de_keep & deh_filt$breaks$hom_keep)*1)
      
      deg_filt <- genoT_nearest_filter(de_filt, distance_cutoff)
      post_deg <- sum(deg_filt$breaks$de_keep*1)
      
      degh_filt <- hom_filter(deg_filt)
      post_degh <- sum((degh_filt$breaks$de_keep & degh_filt$breaks$hom_keep)*1)
      
      deghc_filt <- genoT_cent_filter(degh_filt, cent, assembly, 3000000)
      post_deghc <- sum((deghc_filt$breaks$de_keep & deghc_filt$breaks$hom_keep & deghc_filt$breaks$centromere_keep)*1)
      
      deghc_breaks <- tibble::as_tibble(deghc_filt$breaks[deghc_filt$breaks$de_keep & deghc_filt$breaks$hom_keep & deghc_filt$breaks$centromere_keep])
    }
    
    
    deghc_confint <- dplyr::rename(deghc_breaks, BP.start = start, BP.end = end)
    deghc_confint <- makeGRangesFromDataFrame(deghc_confint, keep.extra.columns=TRUE,
                                             start.field = "CI.start",
                                             end.field = "CI.end")
    # reduce break and confint coordinates to get the largest interval to overlap with true breakpoints
    # if two breakpoints have been merged, reduce before counting, else just count
    deghc_breaks <- reduce(c(deghc_confint[deghc_confint$merged], makeGRangesFromDataFrame(deghc_breaks[deghc_breaks$merged,])))
    deghc_for_tbp_ovlp <- c(deghc_breaks, deghc_confint[!deghc_confint$merged])
    
    # Get false positive negative and true positive for degh filtered breaks
    f_hits <- findOverlaps(tbp[[f]], deghc_for_tbp_ovlp)
    # true
    f_tp <- length(subjectHits(f_hits))
    # false positive
    f_fp <- length(deghc_for_tbp_ovlp) - f_tp
    # false negative
    f_fn <- all_t - f_tp
    
    bp_eval[[f]] <- data.frame(background=bpdata$lib.metrics["background.estimate"],
                               median_breakpoint_res=med_res,
                               true=all_t, tp=tp, fp=fp, fn=fn, post_rf=post_rf, post_de=post_de,
                               post_deh=post_deh, post_deg=post_deg, post_degh=post_degh, post_deghc=post_deghc,
                               deghc_tp=f_tp, deghc_fp=f_fp, deghc_fn=f_fn)
    
    de[[f]] <- de_filt$breaks
    deh[[f]] <- deh_filt$breaks
    deg[[f]] <- deg_filt$breaks
    degh[[f]] <- degh_filt$breaks
    deghc[[f]] <- deghc_filt$breaks
  }
  
  eval_summary_df <- plyr::ldply(bp_eval, rbind)
  
  return(list(summary=eval_summary_df, de_filt=de, deh_filt=deh,
              deg_filt=deg, degh_filt=degh, deghc_filt=deghc))
  
}



