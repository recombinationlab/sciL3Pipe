

#' loads an RData file, and returns it
#' @param f RData file path
#' 
load_RData <- function(f){
  env <- new.env()
  nm <- load(f, env)[1]
  env[[nm]]
}

#' Load breakpoint RData
#' 
#' @param folder Data folder generated by breakpointR
#' @param prefix variable name prefix
load_breakpoint <- function(folder, prefix=NULL, keep_postfix=FALSE, envir=.GlobalEnv){
  rdata_files <- list.files(folder, pattern = "*.RData$", 
                            full.names = TRUE)
  
  for(f in rdata_files){
    if(keep_postfix){
      if(is.null(prefix)){
        f_name <- basename(f)
      }else{
        f_name <- paste(prefix, basename(f), sep = "")
      }
    }else{
      if(is.null(prefix)){
        f_name <- unlist(strsplit(basename(f), ".bam.RData"))
      }else{
        f_name <- paste(prefix, unlist(strsplit(basename(f), ".bam.RData")), sep = "")
      }
    }
    assign(f_name, load_RData(f), envir = envir)
  }
}


#' Extract metrics from BreakPoint object into a summary table
#' background.estimate
#' med.reads.per.MB
#' perc.coverage
#' Number of breaks detected
#' 
#' @param pattern pattern of variables in the GlobalEnv to be used
#' 
breakpoint_summary <- function(pattern){
  all_metrics <- list()
  for(v in ls(pattern = pattern, envir = .GlobalEnv)){
    if("original_breaks" %in% names(get(v))){
      all_metrics[[v]] <- data.frame(as.list(get(v)$lib.metrics),
                                     original_breaks=length(get(v)$original_breaks),
                                     breaks=length(get(v)$breaks))
    }else{
      all_metrics[[v]] <- data.frame(as.list(get(v)$lib.metrics),
                                     breaks=length(get(v)$breaks))
    }
    
  }
  out <- plyr::ldply(all_metrics, rbind)
  return(out)
}




#' Filter two breakpoint event close to each other
#' 
#' @param object BreakPoint class object
#' @param distance_cutoff min distance allowed between two neighbouring breakpoints
double_event_filter <- function(object, distance_cutoff=1000000, pdf_dir=FALSE){
  
  # if pdf_dir does not exist, create it
  if (!file.exists(pdf_dir)){
    dir.create(file.path(pdf_dir))
  }
  
  if(is.character(pdf_dir)){
    cat("Saving PDF:", paste(pdf_dir, object$ID, ".pdf", sep = ""), "\n")
    grDevices::pdf(paste(pdf_dir, object$ID, ".pdf", sep = ""), 
                   width = max(10, length(seqinfo(object$breaks))), 
                   height = 5)
    print(breakpointR::plotBreakpoints(object))
  }
  
  if(length(object$breaks) > 0){
    dtn <- distanceToNearest(object$breaks)
    mcols(object$breaks)$distance <- NA
    object$breaks[queryHits(dtn)]$distance <- mcols(dtn)$distance
    object$original_breaks <- object$breaks
    object$breaks <- object$breaks[object$breaks$distance > distance_cutoff | is.na(object$breaks$distance)]
    
    if(is.character(pdf_dir)){
      print(breakpointR::plotBreakpoints(object))
      grDevices::dev.off()
    }
  }else{
    grDevices::dev.off()
  }
  return(object)
}


#' Filter two breakpoint event close to each other, a version without plotting
#' that only adds a TRUE/FALSE mcolumn to the original breaks GRanges
#' 
#' @param object BreakPoint class object
#' @param distance_cutoff min distance allowed between two neighbouring breakpoints
#' 
de_filter <- function(object, distance_cutoff=1000000){
  
  if(length(object$breaks) > 0){
    dtn <- distanceToNearest(object$breaks)
    mcols(object$breaks)$distance <- NA
    object$breaks[queryHits(dtn)]$distance <- mcols(dtn)$distance
    mcols(object$breaks)$de_keep <- object$breaks$distance > distance_cutoff | is.na(object$breaks$distance)
  }
  return(object)
}

#' breaks that are nearest to each other (inversion breaks), test if they have 
#' the same genotype on either side of the inversion. If yes, filter. If not, 
#' this should be a breakpoint, and should be merged into a single (low resolution)
#' breakpoint
#' 
#' Note: destructive, overwrite the original breaks GRanges in object, should be run last
#' 
#' @param object breakpointR class object
#' @param distance_cutoff distance of proximal breakpoints to assess
#' @param allow_het allow wc or cw genotypes (for diploid)
#' 
genoT_nearest_filter <- function(object, distance_cutoff=2000000, allow_het=FALSE){
  
  # add distance to nearest if not present
  if(!"distance" %in% names(mcols(object$breaks))){
    dtn <- distanceToNearest(object$breaks)
    mcols(object$breaks)$distance <- NA
    object$breaks[queryHits(dtn)]$distance <- mcols(dtn)$distance
  }
  
  # NA to -1 for split to keep all rows
  object$breaks$distance[is.na(object$breaks$distance)] <- -1
  pairs <- split(object$breaks, object$breaks$distance)
  
  final_breaks <- list()
  for(p in seq_along(pairs)){
    n <- as.character(p)
    # if not a proper pair skip filter
    if(length(pairs[[p]]) != 2 | any(pairs[[p]]$distance == -1)){
      final_breaks[[n]] <- pairs[[p]]
    }else if(all(pairs[[p]]$distance <= distance_cutoff)){
      # check order
      stopifnot(start(pairs[[p]][1]) < start(pairs[[p]][2]))
      
      p1g <- substr(pairs[[p]][1]$genoT, 1, 2) 
      p2g <- substr(pairs[[p]][2]$genoT, 4, 5)
      
      # if sides of breaks same, remove both breaks
      if(p1g == p2g){
        next
      }else if(allow_het){
        # create new ranges with pairs merged
        final_breaks[[n]] <- merge_bR_pairs(pairs[[p]])
      }else if(p1g %in% c("ww", "cc") & p2g %in% c("ww", "cc") & p1g != p2g){
        final_breaks[[n]] <- merge_bR_pairs(pairs[[p]])
      }
    # anything more than distance cutoff write out
    }else{
      final_breaks[[n]] <- pairs[[p]]
    }
  }
 object$breaks <- unlist(GRangesList(final_breaks))
 
 return(object)
}
  

  
#'Merge a Pair of GRanges
#'
#'Note: requires distance column
#'
#'@param pairs GRanges with two ranges with equal distance from each other
#'
merge_bR_pairs <- function(pair){
  stopifnot("distance" %in% names(mcols(pair)))
  
  dist <- ifelse(pair[1]$distance == pair[2]$distance, pair[1]$distance, stop("Distance unequal"))
  
  p1g <- substr(pair[1]$genoT, 1, 2) 
  p2g <- substr(pair[2]$genoT, 4, 5)
  
  # merge pair coordinates
  m_pair <- reduce(pair, min.gapwidth= dist+1)
  mcols(m_pair) <- mcols(pair[1])
  mcols(m_pair)$genoT <- paste(p1g, p2g, sep = "-")
  mcols(m_pair)$deltaW <- mean(pair[1]$deltaW, pair[2]$deltaW)
  mcols(m_pair)$distance <- -1
  mcols(m_pair)$de_keep <- TRUE
  
  return(m_pair)
}
  
  # seqnames     start       end    width strand genoT deltaW distance de_keep
  # 1         1 120447865 145462905 25015041      * ww-cc     12  1881056   FALSE
  # 2         1 147343962 149121706  1777745      * cc-ww     11  1881056   FALSE
  # 3         8  24372672  24816691   444020      * ww-wc      6   483415   FALSE
  # 4         8  25300107  25719608   419502      * wc-ww      6   483415   FALSE
  # 5         9 133300206 133971276   671071      * ww-cc     14       NA    TRUE
  # 6        10  46032485  46967406   934922      * cc-wc      8  1645976   FALSE
  # 7        10  48613383  49507614   894232      * wc-cc      6  1645976   FALSE
  # 8        12  63132183  63270986   138804      * ww-cc      9   749859   FALSE
  # 9        12  64020846  64410553   389708      * cc-ww      9   749859   FALSE
  # 10       15  23701352  23977707   276356      * ww-cc     13 36611739    TRUE
  # 11       15  60589447  61121067   531621      * cc-wc     12 11481023    TRUE
  # 12       15  72602091  72604997     2907      * wc-cc     11  1709137   FALSE
  # 13       15  74314135  74511749   197615      * cc-wc     11  1709137   FALSE
  # 14       15  89828254  89849202    20949      * wc-cc      9 15316504    TRUE
  # 15       22  23716264  23756067    39804      * cc-ww      9       NA    TRUE




#' Heterozygous breakpoint filter, useful for haploid cell lines
#' 
#' #' @param object BreakPoint class object
#' 
hom_filter <- function(object){
  if(length(object$breaks) > 0){
    mcols(object$breaks)$hom_keep <- mcols(object$breaks)$genoT == "cc-ww" | mcols(object$breaks)$genoT == "ww-cc"
  }
  return(object)
}




#' Get centromere coordinates from UCSC 
#' 
#' Note: in hg19 centromeres are treated as gaps
#' trackNames(ucscTableQuery(session))
#' 
#' @param genome e.g. hg38
#' @param reduce_single reduce to a single coordinate per chromosome (for hg38 that contains centromeres)
#' 
get_centromere_coordinates <- function(genome, reduce_single=FALSE){
  if (!(exists("session") && extends(class(session), "BrowserSession"))) 
    session <- rtracklayer::browserSession()
  if(genome == "hg38"){
    tryres <- try(query <- rtracklayer::ucscTableQuery(session, "centromeres", genome))
  }else {
    tryres <- try(query <- rtracklayer::ucscTableQuery(session, "gap", genome))
  }
  
  
  if (!inherits(tryres, "try-error")) {
    df <- rtracklayer::getTable(query)
    if(genome != "hg38"){
      df <- df[df$type == "centromere",]
    }
    gr <- GRanges(seqnames = df$chrom, IRanges(start = df$chromStart, 
                                               end = df$chromEnd))
  } else {
    message("Centromere informatin is not available.")
  }
  
  if(reduce_single){
    max_dist <- max(mcols(distanceToNearest(gr))$distance)
    gr <- reduce(gr, min.gapwidth= max_dist+1)
  }
  
  return(gr)
}



#' Load file with all breakpoints including columns:
#' seqnames start end CI.start CI.end genoT filenames
#' 
#' Makes a list with breakpoints for each sample in summary file
#' 
#' @param file_path path to breakPointsSummary*.txt file
#' 
load_breakpoint_summary <- function(file_path){
  # space delimited, can't import as a BED file
  bp_summary <- readr::read_table2(file_path)
  # remove breakpoint number from filenames
  bp_summary$filenames <- gsub(".\\d+$", "", bp_summary$filenames)
  bp_summary <- makeGRangesFromDataFrame(bp_summary, keep.extra.columns=TRUE)
  
  summary_list <- split(bp_summary, bp_summary$filenames)
  
  return(summary_list)
}



#' Exclude chromosomes or certain regions as possible sites of breakpoints
#' 
#' @param object breakpoint class object
#' @param region either chromosome "15" or region "15:1-500" to exclude
#' 
#' @return breakpoint class object with region_filter column added to breaks GRanges
#' 
filter_regions <- function(object, region){
  if(grepl(":|-", region)){
    region <- gsub(":", "-", region)
    rs <- unlist(strsplit(region, "-"))
    region <- GRanges(seqnames = rs[1], 
                      ranges = IRanges(start=as.numeric(rs[2]), end=as.numeric(rs[3])))
    hits <- findOverlaps(object$breaks, region)
    # exclude overlaps
    mcols(object$breaks)$region_filter <- !object$breaks %in% object$breaks[queryHits(hits)]
  }else{
    mcols(object$breaks)$region_filter <- !seqnames(object$breaks) %in% region
  }
  return(object)
}

